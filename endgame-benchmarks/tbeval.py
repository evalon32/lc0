#!/usr/bin/python3

__doc__ = """
Runs MCTS search on a collection of board positions generated by tbgen.py
and computes various metrics (see COLUMNS below).
The output is a table in CSV format (can be imported into sqlite, spreadsheets,
etc.)
"""

import argparse
import chess
import chess.uci
import collections
import csv
from operator import attrgetter
import os
import os.path
import re
import sys
from typing import Dict

COLUMNS = [
    # Position properties (engine-independent)
    'ID',       # Position identifier from EPD
    'Code',     # Piece configuration (KBNk etc.)
    'HMVC',     # Half-move clock (aka 50-move rule counter)
    'DTM',      # Distance to mate with optimal play (in full moves)
    'R50',      # Would optimal moves be different without the 50-move rule?
    'RNG_Opt',  # Probability that a random move is optimal (listed in 'bm')
    'RNG_OK',   # Probability that a random move is winning (NOT listed in 'am')

    # Engine configuration
    'Version',  # LC0 version
    'Model',    # Network ID
    'Nodes',    # MCTS node limit
    'Options',  # Additional options (--extra_lc0_args)

    # Probabilities of optimal/winning moves
    # - after MCTS or with pure network policy priors
    # - with temperature 0 or 1 (with T=0, the probability is either 0 or 1)
    'MCTS_T0_Opt',
    'MCTS_T0_OK',
    'MCTS_T1_Opt',
    'MCTS_T1_OK',
    'Policy_T0_Opt',
    'Policy_T0_OK',
    'Policy_T1_Opt',
    'Policy_T1_OK',
    # Expected Q value of the selected move
    'MCTS_T0_Q',
    'MCTS_T1_Q',  # same as the parent node's Q
]

MoveInfo = collections.namedtuple('MoveInfo', ['N', 'P', 'Q'])

class VerboseInfoHandler(chess.uci.InfoHandler):
    """Parses LC0's verbose move stats from 'info string' lines."""

    _VERBOSE_INFO_PATTERN = re.compile(
        # Adjust as necessary to match LC0 output format.
        r"""(?P<Move>\w+) \s*
        .*
        \s N: \s* (?P<N> \d+ ) \s
        .*
        \( P: \s* (?P<P> [\d\.]+ )%  \)
        .*
        \( Q: \s* (?P<Q> -?[\d\.]+ ) \)
        .*""",
        re.X)

    def __init__(self):
        super().__init__()
        self.move_info: Dict[chess.Move, MoveInfo] = dict()

    def post_info(self):
        if 'string' in self.info:
            match = re.match(self._VERBOSE_INFO_PATTERN, self.info['string'])
            if match:
                move = chess.Move.from_uci(match.group('Move'))
                self.move_info[move] = MoveInfo(
                    N = int(match.group('N')),
                    P = float(match.group('P')) / 100,
                    Q = float(match.group('Q')),
                )
        super().post_info()


class Evaluator:
    def __init__(self, lc0_binary: str, weights_dir: str, weights_id: int,
                 extra_lc0_args: str):
        weights_file = os.path.join(weights_dir,
                                    'weights_{}.txt.gz'.format(weights_id))
        assert os.path.exists(weights_file)
        self._engine = chess.uci.popen_engine(
            [lc0_binary, '--weights=' + weights_file,
             '--threads=1', '--verbose-move-stats'] +
            extra_lc0_args.split())
        self._engine.uci()
        lc0_version = self._engine.name.split()[-1]
        self._info_handler = VerboseInfoHandler()
        self._engine.info_handlers.append(self._info_handler)
        self._fixed_fields = dict(
            Version = lc0_version,
            Model = weights_id,
            Options = extra_lc0_args,
        )

    def eval_epd(self, epd: str, mcts_nodes: int) -> dict:
        board, epd_info = chess.Board.from_epd(epd)

        legal_moves = set(board.legal_moves)
        optimal_moves = set(epd_info['bm'])
        ok_moves = legal_moves - set(epd_info['am']) if 'am' in epd_info \
                   else legal_moves

        record = dict(
            ID = epd_info['id'],
            Code = self._poscode(board),
            HMVC = board.halfmove_clock,
            DTM = epd_info['dm'],
            R50 = int('R50' in epd_info),
            RNG_Opt = len(optimal_moves) / len(legal_moves),
            RNG_OK = len(ok_moves) / len(legal_moves),
            Nodes = mcts_nodes,
        )
        record.update(self._fixed_fields)

        move_info, policy_bestmove, mcts_bestmove = self._search(board,
                                                                 mcts_nodes)
        assert move_info.keys() == legal_moves

        n_total = sum(x.N for x in move_info.values())
        assert n_total == self._info_handler.info['nodes'] - 1
        p_total = sum(x.P for x in move_info.values())
        # p_total should be 1, but there's some margin of error during
        # normalization (not sure how much) and then up to 0.005%/move
        # when the P values are printed.
        # assert abs(p_total - 1) < len(legal_moves) * 0.00005

        for alg, attr, total, bestmove in [
                ('MCTS', 'N', n_total, mcts_bestmove),
                ('Policy', 'P', p_total, policy_bestmove)]:
            for grade, moves in [
                    ('Opt', optimal_moves),
                    ('OK', ok_moves)]:
                w = sum(getattr(move_info[move], attr) for move in moves)
                record['{}_T1_{}'.format(alg, grade)] = w / total
                record['{}_T0_{}'.format(alg, grade)] = int(bestmove in moves)

        record.update(
            MCTS_T0_Q = move_info[mcts_bestmove].Q,
            MCTS_T1_Q = sum(x.N * x.Q for x in move_info.values()) / n_total,
        )

        return record

    def _search(self, board: chess.Board, nodes: int) -> (
            Dict[chess.Move, MoveInfo], chess.Move, chess.Move):
        self._engine.ucinewgame()
        self._engine.position(board)
        self._info_handler.move_info = dict()
        policy_bestmove = self._engine.go(nodes=0).bestmove
        mcts_bestmove = self._engine.go(nodes=nodes).bestmove
        return self._info_handler.move_info, policy_bestmove, mcts_bestmove

    @staticmethod
    def _poscode(board: chess.Board) -> str:
        pieces = board.piece_map().values()
        sorted_pieces = sorted(pieces,
                               key=attrgetter('color', 'piece_type'),
                               reverse=True)
        return ''.join(piece.symbol() for piece in sorted_pieces)


if __name__ == '__main__':
    argparser = argparse.ArgumentParser(
        description='Evaluate positions from an EPD file with LC0')
    argparser.add_argument('--input', type=argparse.FileType('r'),
                           default=sys.stdin)
    argparser.add_argument('--output', type=argparse.FileType('w'),
                           default=sys.stdout)
    argparser.add_argument('--lc0_binary', default='lc0')
    argparser.add_argument('--weights_dir', default=os.path.join(
        os.environ['HOME'], 'LCZ/experimental-networks'))
    argparser.add_argument('--weights_id', type=int, required=True)      
    argparser.add_argument('--mcts_nodes', type=int, default=800)
    argparser.add_argument('--extra_lc0_args', default='')

    args = argparser.parse_args()

    evaluator = Evaluator(lc0_binary=args.lc0_binary,
                          weights_dir=args.weights_dir,
                          weights_id=args.weights_id,
                          extra_lc0_args=args.extra_lc0_args)
    writer = csv.DictWriter(args.output, COLUMNS)
    writer.writeheader()
    writer.writerows(evaluator.eval_epd(epd, mcts_nodes=args.mcts_nodes)
                     for epd in args.input)
    args.output.flush()
